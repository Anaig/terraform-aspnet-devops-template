# CI/CD Azure DevOps deployment pipeline.
# The following variables can be optionally set for each pipeline run:
# - RUN_FLAG_TERRAFORM: Set to 1 to have `terraform apply`. By default
#   `terraform apply` only runs on the master branch.
# - RUN_FLAG_PROMOTE: Set to 1 to promote the Docker image to `latest` tag if
#   tests are successful. By default this is only done on the master branch.
# - RUN_SET_NAMEBASE: Set to a string to deploy to the given AKS namespace,
#   and not delete the namespace after the build. By default the build deploys to
#   the `master` AKS namespace if run on the master branch, and otherwise to a
#   temporary AKS namespace that is deleted at the end of the build.

jobs:
- job: Terraform_shared
  displayName: Deploy shared infrastructure
  # Avoid concurrent Terraform runs on PRs, which would result in failures due to exclusive lock on remote state file.
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), variables['RUN_FLAG_TERRAFORM']))
  variables:
    TERRAFORM_DIRECTORY: infrastructure/terraform-shared
  steps:

  - template: terraform-init-template.yml
    parameters:
      TerraformStateKey: cd

  - bash: |
      set -euo pipefail
      curl -sfu ":$(AGENT_POOL_MANAGEMENT_TOKEN)" '$(System.CollectionUri)_apis/distributedtask/pools?poolName=$(AGENT_POOL_NAME)&actionFilter=manage&api-version=5.1' \
        | jq -e '.count>0'
    displayName: Verify agent pool token

  - bash: |
      set -eu
      terraform plan -out=tfplan -input=false \
        -var environment=cd \
        -var resource_group=$(RESOURCE_GROUP) \
        -var vnet_name=$(VNET_NAME) \
        -var acr_name=$(ACR_NAME) \
        -var aks_name=$(AKS_NAME) \
        -var aks_version=$(AKS_VERSION) \
        -var aks_sp_client_id=$(AKS_SP_CLIENT_ID) \
        -var aks_sp_object_id=$(AKS_SP_OBJECT_ID) \
        -var kusto_name=$(KUSTO_NAME) \
        -var kusto_admin_sp_object_id=$(AKS_SP_OBJECT_ID) \
        -var az_devops_agent_pool=$(AGENT_POOL_NAME) \
        -var az_devops_url=$(System.CollectionUri) \
        -var az_devops_pat=$(AGENT_POOL_MANAGEMENT_TOKEN) \
        ;
        terraform apply -input=false -auto-approve tfplan
    displayName: Terraform apply
    workingDirectory: $(TERRAFORM_DIRECTORY)
    # For additional security, pass secret through environment instead of command line.
    # Terraform recognizes the TF_VAR prefixed environment variables.
    env:
      TF_VAR_aks_sp_client_secret: $(AKS_SP_CLIENT_SECRET)
      ARM_CLIENT_ID: $(TERRAFORM_SP_CLIENT_ID)
      ARM_CLIENT_SECRET: $(TERRAFORM_SP_CLIENT_SECRET)


- job: Terraform_shared_outputs
  displayName: Read shared infrastructure
  dependsOn:
  - Terraform_shared
  condition: |
    in(dependencies.Terraform_shared.result, 'Succeeded', 'SucceededWithIssues', 'Skipped')
  variables:
    TERRAFORM_DIRECTORY: infrastructure/terraform-shared
  steps:

  - template: terraform-init-template.yml
    parameters:
      TerraformStateKey: cd

  - template: terraform-outputs-template.yml

- job: Start_agents
  displayName: Start agents
  dependsOn:
  - Terraform_shared_outputs
  variables:
    AGENT_VMSS_ID: $[ dependencies.Terraform_shared_outputs.outputs['Outputs.agent_vmss_id'] ]
    TERRAFORM_DIRECTORY: infrastructure/terraform-shared
  steps:

  - task: AzureCLI@1
    displayName: Start agents
    inputs:
      azureSubscription: Terraform
      scriptLocation: inlineScript
      inlineScript: |
        set -eux  # fail on error
        az vmss scale --id $AGENT_VMSS_ID --new-capacity 2 -o table

- job: Terraform
  displayName: Deploy infrastructure
  pool: $(AGENT_POOL_NAME)
  dependsOn:
  - Terraform_shared_outputs
  variables:
    KUBE_CONFIG_BASE64: $[ dependencies.Terraform_shared_outputs.outputs['Outputs.kube_config_base64'] ]
    KUSTO_NAME: $[ dependencies.Terraform_shared_outputs.outputs['Outputs.kusto_name'] ]
    TERRAFORM_DIRECTORY: infrastructure/terraform
  steps:

  - bash: |
      set -eu  # fail on error
      base64 -d <<< $KUBE_CONFIG_BASE64 > kube_config
      echo "##vso[task.setvariable variable=KUBECONFIG]$PWD/kube_config"
    displayName: Save kubeconfig
    env:
      KUBE_CONFIG_BASE64: $(KUBE_CONFIG_BASE64)

  - bash: |
      set -eu  # fail on error

      KUBERNETES_NAMESPACE="build$(Build.BuildId)"
      if [ "$(Build.SourceBranch)" = "refs/heads/master" ]; then
        KUBERNETES_NAMESPACE="master"
      fi
      if [ "${RUN_SET_NAMEBASE:-}" != "" ]; then
        KUBERNETES_NAMESPACE="$RUN_SET_NAMEBASE"
      fi

      echo "Namespace: $KUBERNETES_NAMESPACE"

      echo "##vso[task.setvariable variable=KUBERNETES_NAMESPACE]$KUBERNETES_NAMESPACE"

    displayName: Define AKS namespace

  - template: terraform-init-template.yml
    parameters:
      TerraformStateKey: cd-$(Build.BuildId)

  - bash: |
      set -eu
      terraform plan -out=tfplan -input=false \
        -var resource_group=$(RESOURCE_GROUP) \
        -var kusto_cluster_name=$(KUSTO_NAME) \
        -var kusto_database_name=$(KUSTO_DB) \
        -var kubernetes_namespace=$(KUBERNETES_NAMESPACE) \
        -var release_name="$(HELM_RELEASE_NAME)" \
        -var image_repository="$(ACR_NAME).azurecr.io/contoso" \
        -var image_tag="$(SEMANTIC_VERSION)" \
        -var client_id="$(AKS_SP_CLIENT_ID)" \
        -var tenant_id="$(ARM_TENANT_ID)" \
        ;
        terraform apply -input=false -auto-approve tfplan
    displayName: Terraform apply
    workingDirectory: $(TERRAFORM_DIRECTORY)
    env:
      ARM_CLIENT_ID: $(TERRAFORM_SP_CLIENT_ID)
      ARM_CLIENT_SECRET: $(TERRAFORM_SP_CLIENT_SECRET)
      TF_VAR_client_secret: $(AKS_SP_CLIENT_SECRET)

  - template: terraform-outputs-template.yml

- job: security_analysis
  displayName: Security analysis
  condition: false

  pool:
    # CredScan only runs on Windows
    vmImage: 'windows-latest'

  steps:
  - task: CredScan@2
    displayName: 'Find credentials in source code'
    inputs:
      toolMajorVersion: 'V2'

# - task: SdtReport@1
#   displayName: 'Security analysis report'
#   inputs:
#     AllTools: false
#     APIScan: false
#     BinSkim: false
#     CodesignValidation: false
#     CredScan: true
#     FortifySCA: false
#     FxCop: false
#     ModernCop: false
#     MSRD: false
#     PoliCheck: false
#     RoslynAnalyzers: false
#     SDLNativeRules: false
#     Semmle: false
#     TSLint: false
#     ToolLogsNotFoundAction: 'Standard'

  - task: PublishSecurityAnalysisLogs@2
    displayName: 'Publish security analysis logs'
    inputs:
      ArtifactName: 'CodeAnalysisLogs'
      ArtifactType: 'Container'
      AllTools: false
      AntiMalware: false
      APIScan: false
      BinSkim: false
      CodesignValidation: false
      CredScan: true
      FortifySCA: false
      FxCop: false
      ModernCop: false
      MSRD: false
      PoliCheck: false
      RoslynAnalyzers: false
      SDLNativeRules: false
      Semmle: false
      TSLint: false
      WebScout: false
      ToolLogsNotFoundAction: 'Standard'

  - task: PostAnalysis@1
    displayName: 'Post security analysis'
    inputs:
      AllTools: false
      APIScan: false
      BinSkim: false
      CodesignValidation: false
      CredScan: true
      FortifySCA: false
      FxCop: false
      ModernCop: false
      PoliCheck: false
      RoslynAnalyzers: false
      SDLNativeRules: false
      Semmle: false
      TSLint: false
      VstsConsole: false
      ToolLogsNotFoundAction: 'Standard'

  - task: ComponentGovernanceComponentDetection@0
    inputs:
      scanType: 'Register'
      verbosity: 'Verbose'
      alertWarningLevel: 'Medium'
      failOnAlert: true

- job: build
  displayName: Build and unit tests
  pool: $(AGENT_POOL_NAME)
  steps:

  - bash: |
      set -eux  # fail on error
      # Only build first stage of Dockerfile (build and unit test)
      docker build --pull --target testrunner --build-arg VersionPrefix="$(SEMANTIC_VERSION)" -t contoso-build-$(Build.BuildId):test .
      docker run --rm -v $PWD/TestResults:/app/Contoso.UnitTests/TestResults contoso-build-$(Build.BuildId):test
    displayName: Docker build & test

  - task: PublishTestResults@2
    displayName: Publish test results
    condition: succeededOrFailed()
    inputs:
      testRunner: VSTest
      testResultsFiles: '**/*.trx'
      failTaskOnFailedTests: true
      testRunTitle: 'Unit Tests'

  #FIXME
  - bash: echo "##vso[task.setvariable variable=HOME]."

  - task: UseDotNet@2
    displayName: Use .NET Core for coverage report generation
    inputs:
      packageType: sdk
      version: 3.1.200

  # Publish the code coverage result (summary and web site)
  # The summary allows to view the coverage percentage in the summary tab
  # The web site allows to view which lines are covered directly in Azure Pipeline
  - task: PublishCodeCoverageResults@1
    displayName: 'Publish code coverage'
    inputs:
      codeCoverageTool: 'Cobertura'
      summaryFileLocation: '**/coverage.cobertura.xml'
      pathToSources: '$(Build.SourcesDirectory)/Src'
      failIfCoverageEmpty: true

  - task: AzureCLI@1
    displayName: Build images and charts
    inputs:
      azureSubscription: $(ACR_PUSH_SERVICE_CONNECTION)
      scriptLocation: inlineScript
      inlineScript: |
        set -eux  # fail on error

        az configure --defaults acr="$ACR_NAME"
        az acr login

        # Build runtime Docker image
        # Reuses the cached build stage from the previous docker build task
        docker build --build-arg VersionPrefix="$(SEMANTIC_VERSION)" \
          -t "$ACR_NAME.azurecr.io/contoso:$(SEMANTIC_VERSION)" \
          .

        # Push Docker image to ACR
        docker push "$ACR_NAME.azurecr.io/contoso:$SEMANTIC_VERSION"

- job: integration_tests
  displayName: Integration tests
  pool: $(AGENT_POOL_NAME)
  dependsOn:
  - build
  - Terraform
  - Terraform_shared_outputs
  variables:
    KUBE_CONFIG_BASE64: $[ dependencies.Terraform_shared_outputs.outputs['Outputs.kube_config_base64'] ]
    KUBERNETES_NAMESPACE: $[ dependencies.Terraform.outputs['Outputs.kubernetes_namespace'] ]
  steps:

  - bash: |
      set -eu  # fail on error
      base64 -d <<< $KUBE_CONFIG_BASE64 > kube_config
      echo "##vso[task.setvariable variable=KUBECONFIG]$PWD/kube_config"
    displayName: Save kubeconfig
    env:
      KUBE_CONFIG_BASE64: $(KUBE_CONFIG_BASE64)

  - task: KubectlInstaller@0
    displayName: Install kubectl
    inputs:
      kubectlVersion: $(AKS_VERSION)

  #FIXME
  - bash: |
     sudo apt-get install openjdk-8-jdk
    displayName: FIXME Install Java

  - task: AlexandreGattiker.jmeter-tasks.custom-jmeter-installer-task.JMeterInstaller@0
    displayName: 'Install JMeter'
    inputs:
      jmeterVersion: $(JMETER_VERSION)
      plugins: jpgc-casutg,jpgc-dummy,jpgc-ffw,jpgc-fifo,jpgc-functions,jpgc-json,jpgc-perfmon,jpgc-prmctl,jpgc-tst,jmeter.backendlistener.azure

  #FIXME
  - bash: |
     sudo add-apt-repository ppa:deadsnakes/ppa
     sudo apt update
     sudo apt install python3.6 python3-pip python3.6-dev
     python3.6 -mpip install --upgrade urllib3
    displayName: FIXME Install Python 3.6 (for Ubuntu 16)

  - task: AlexandreGattiker.jmeter-tasks.custom-taurus-installer-task.TaurusInstaller@0
    displayName: 'Install Taurus'
    inputs:
      taurusVersion: 1.14.1
      pythonCommand: python3.6

  - bash: kubectl -n "$KUBERNETES_NAMESPACE" rollout status deployment "$(HELM_RELEASE_NAME)" --timeout 5m
    displayName: Await K2 deployment

  - bash: |
      set -eux  # fail on error
      kubectl -n "$KUBERNETES_NAMESPACE" run --attach --rm --restart=Never --image=busybox smoke-test-$(HELM_RELEASE_NAME) -- \
        wget -O- \
        'http://$(HELM_RELEASE_NAME)'
    displayName: Smoke test

  - bash: |
      set -eux  # fail on error
      read -d, firstNodeIP < <(kubectl -n "$KUBERNETES_NAMESPACE" get nodes -o jsonpath="{.items[0].status.addresses[?(@.type=='InternalIP')].address},")
      read -d, nodePort < <(kubectl -n "$KUBERNETES_NAMESPACE" get svc "$(HELM_RELEASE_NAME)" -o jsonpath="{.spec.ports[0].nodePort},")
      url="http://$firstNodeIP:$nodePort"
      echo "##vso[task.setvariable variable=SERVICE_URL]$url"
      echo "$url"
    displayName: Get Service URL

  - bash: |
      curl -fv $SERVICE_URL
    displayName: Smoke test 2

  - task: AlexandreGattiker.jmeter-tasks.custom-taurus-runner-task.TaurusRunner@0
    displayName: 'Run Taurus'
    inputs:
      taurusConfig: |
        modules:
          jmeter:
            properties:
              jmeter.reportgenerator.overall_granularity: 5000
        execution:
        - scenario:
            requests:
            - $(SERVICE_URL)
          concurrency: 10
          ramp-up: 15s
          hold-for: 2m
          iterations: 10000
        reporting:
        - module: junit-xml
          filename: taurus-output/TEST-Taurus.xml


  - task: PublishTestResults@2
    displayName: Publish test results
    inputs:
      testRunTitle: Integration tests
      failTaskOnFailedTests: true

- job: Cleanup
  displayName: Delete infrastructure
  dependsOn:
  - integration_tests
  - Terraform_shared_outputs
  pool: $(AGENT_POOL_NAME)
  # Do not delete AKS namespace:
  # - if deploying on master branch
  # - if namespace was manually set with RUN_SET_NAMEBASE
  condition: and(always(), not(eq(variables['KUBERNETES_NAMESPACE'], 'master')), not(variables['RUN_SET_NAMEBASE']))
  variables:
    KUBE_CONFIG_BASE64: $[ dependencies.Terraform_shared_outputs.outputs['Outputs.kube_config_base64'] ]
    TERRAFORM_DIRECTORY: infrastructure/terraform-destroy
  steps:

  - bash: |
      set -eu  # fail on error
      base64 -d <<< $KUBE_CONFIG_BASE64 > kube_config
      echo "##vso[task.setvariable variable=KUBECONFIG]$PWD/kube_config"
    displayName: Save kubeconfig
    env:
      KUBE_CONFIG_BASE64: $(KUBE_CONFIG_BASE64)

  - template: terraform-init-template.yml
    parameters:
      TerraformStateKey: cd-$(Build.BuildId)

  - bash: |
      set -eu
      terraform destroy -input=false -auto-approve
    displayName: Terraform destroy
    workingDirectory: $(TERRAFORM_DIRECTORY)
    env:
      ARM_CLIENT_ID: $(TERRAFORM_SP_CLIENT_ID)
      ARM_CLIENT_SECRET: $(TERRAFORM_SP_CLIENT_SECRET)

- job: Promote
  displayName: Promote latest image
  dependsOn: integration_tests
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), variables['RUN_FLAG_PROMOTE']))
  steps:

  - task: AzureCLI@1
    displayName: Tag Docker image as latest
    inputs:
      azureSubscription: $(ACR_PUSH_SERVICE_CONNECTION)
      scriptLocation: inlineScript
      inlineScript: |
        set -eux  # fail on error
        az configure --defaults acr="$ACR_NAME"
        az acr login
        docker pull "$ACR_NAME.azurecr.io/contoso:$SEMANTIC_VERSION"
        docker tag \
          "$ACR_NAME.azurecr.io/contoso:$SEMANTIC_VERSION" \
          "$ACR_NAME.azurecr.io/contoso:latest"
        docker push "$ACR_NAME.azurecr.io/contoso:latest"
